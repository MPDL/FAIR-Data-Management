---
title: "1) Organization"
link-external-newwindow: true
---


## General notes

A clear and consistent folder structure and folder and file name convention is important for making your data findable. You should think about it aforehand in order to avoid inconsistencies or the need for renaming your data.

Your structure and your naming conventions should be intuitive. However, you should explicitly describe them (typically in a README file), because they may not be that intuitive for others, or for yourself in future ("why did I do that like this?").



## General task

Check the file (and potentially folder) structure of the dataset.

::: {.callout-tip collapse="false" icon="true" title="Tasks (\~ 30 minutes)"}
For each of the aspects mentioned in the sections below, please do following:

- Check the current situation:
  - What is done how and why?
- Discuss:
  - What would you keep like it is, what would you do better or which alternatives exist? Why?
- Then, improve the dataset (or just briefly mention the improvements you would do, in case you have not enough time).
:::

The most important action here is to discuss, because for most aspects, there are several possible solutions.


## Aspects to look at

Following are some aspects to look at. Not all of them may apply to all datasets. Besides the tasks (green boxes), there are some general hints and rules given.

Some of the rules are not applicable for all use cases, and sometimes there are good arguments for not sticking to every rule. However, in such case you should know (and potentially document) why you decide differently.


### Folder structure

Depending on the structure of your data and documentation, you have to decide on how to arrange your files and folders.
This may also require judgment and compromises: Many files per folder versus deep folder structure, intuitive names versus strict conventions, structuring either by processing level or permissions or size or ...

::: {.callout-tip collapse="false" icon="true" title="Check (\~ 5 minutes)"}
- Is the folder structure intuitive and logical?
- Is it explicitly described? Where (metadata of repository or in a readme file)?
- How many files per folder, how deeply nested?
:::

::: {.callout-warning collapse="false" icon="true" title="Avoid too long file paths."}
Depending on the operating system, there is an upper limit of the total path length, e.g. 255 characters. And if you synchronize or backup your data, the path of the copy might be even longer than your orginal path, in which case your sync or backup job might fail.
Therefore try to keep your full path clearly below such upper limits.

- Bad example: `X:/Projects/Microscopy_Project/Microscopy_Projects_2024/October_2024/RawData_October2024/Microscopy_RawData_Image0003.tif`
- Better: `X:/Projects/Microscopy/2024-10/RawData/Image003.tif`
:::

::: {.callout-note collapse="true" icon="true" title="Further hints about folder structure"}
* Avoid too deeply nested folder structures: SubSubSubSubSubFolders can be quite inconvenient.
* Avoid too many files or subfolders within one folder.\
  It can be quite inconvenient to look through dozens of heterogeneous file names. In case of clearly structured file names (e.g. numbered files like "Image003.tif" or "Plot01_Part03.tab"), also larger number of elements per folder can be fine. But for very many files (several thousands), the performance of the file explorer may decrease.
* In case different project members should have different access restrictions to files, this could be considered in your folder structure.
:::

::: {.callout-note collapse="true" icon="false" title="Examples"}

Example for structuring a dataset: organized by File type, adapted from [https://datadryad.org/stash/best_practices#organize](https://datadryad.org/stash/best_practices#organize)

```
+ DatasetA
  + Data
    + Processed
    + Raw
  + Results
    + Figure1.tif
    + Figure2.tif
```

Example for structuring a dataset: organized by Analysis, adapted from [https://datadryad.org/stash/best_practices#organize](https://datadryad.org/stash/best_practices#organize)

```
+ DatasetB
  + Figure1
    + RawData
    + Results
      + Figure1.tif
  + Figure2
    + RawData
    + Results
      + Figure2.tif
```

Example for a project folder structure: adapted from Suse Prejawa (2021, [https://hdl.handle.net/21.11116/0000-0008-662A-7](https://hdl.handle.net/21.11116/0000-0008-662A-7))

```
+ Project_Folder
  + 1_Project_Management
    + Finance
    + Proposals
    + Reports
  + 2_Ethics_and_Governance
    + Consent_Forms
    + Ethical_Approvals
  + 3_Dissemination
    + Presentations
    + Publications
    + Publicity
  + Experiment_01
    + Data
    + Data_Analysis
    + Inputs
    + Outputs
```

Example for a project folder structure: adapted from template used at the Max Planck Institute for Chemistry, used for measurement projects/campaigns (e.g. with a research aircraft)

```
\\file.mpic.de\projects\ExampleProject\
  + GeneralOverview  # General documentation of the project
  + Meetings         # Meeting notes, presentations
  + INST             # Instruments
    + Instrument1    # One folder per instrument
      + Doc          # Documentation for this instrument
      + L_0          # Raw data
      + L_2          # Processed/analyzed data on original resolution
        + Product1   # One folder per data product
          + Code     # Code used for creating the data of this product
          + Data     # Data files of this product
          + Doc      # Documentation for this data product
      + L_3          # Gridded data products
        + Product1   # One folder per data product (e.g. hourly averages)
          + Code     # Code used for creating the data of this product
          + Data     # Data files of this product
          + Doc      # Documentation for this data product
      + Labbook      # Labbook (photos of paper logbook or exports from ELN)
```

:::


### File and folder names

File or folder names have following major purposes:

* Always: Uniquely (within a folder) identify the file or folder
* Often: Give information about its content, e.g. `README.txt`, `MeetingProtocol.docx`, `Temperature_RawData.tab`
* Sometimes: Enable logical order when sorting alphabetically, e.g. `1_RawData`, `2_PreProcessed`, `3_Processed`, `4_Combined`

For the naming of folders, widely the same rules apply as for files. They shall allow to choose the desired file amongst all the other files of the folder. Therefor, the names should be concise and intuitive (if applicable). In particular in case of non-intuitive names, they have to be explained somewhere, typically in a README file. Well-structured folders have clear naming conventions, which are explicitly described.

::: {.callout-tip collapse="false" icon="true" title="Check (\~ 10 minutes)"}
- What is the convention of the naming? Is it intuitive and logical? Is it explicitly described?
- Are the names meaningful?
- Are there misleading names?
- In case of many files: Do they show up in a logical order when sorting alphabetically?
- Are there problematic characters like spaces, non-ASCII characters etc?
- Length of the name
:::

::: {.callout-warning collapse="false" icon="true" title="Do not use bad characters."}
Depending on the operating system etc, some characters are forbidden or may lead to problems, and thus should be avoided.

- Very bad: any non-ASCII character, e.g.: `öäüßµαδ°±•€→☺É`
- Bad: any whitespace character, e.g. `File 1.txt`. They can cause problems e.g. in some batch tasks, in particular if on forgets to surround the name with quotes. Furthermore, double or multiple spaces, and spaces at the begin of the name are not clearly visible.
- Forbidden in Windows: `\/:*?"<>|`
- Also not recommended: `,;()[]{}` etc

To summarize: You should only use latin letters A-Z, a-z, digits 0-9, underscore, hyphen and dot, i.e. following characters: `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456789_-.`

The dot should only be used in file names, and there only once, namely before the line extension, e.g. "Notes.txt".

Some programs use dot or underscore as first character for special files, e.g. `_quarto.yml` or `.git` and thus should be avoided for regular data files.
:::

::: {.callout-warning collapse="true" icon="true" title="No 'hello.txt' and 'Hello.txt' in same folder"}
Take care, that subfolders and files have unique names within a common folder, even in a case-insensitive way. For example, do not put two files named `hello.txt` and `Hello.txt` in the same folder.

This note is in particular relevant for Linux users, where it would be possible to put both files in same folder. But in Windows that is not allowed, thus sharing such a folder would cause problems.
:::

::: {.callout-note collapse="true" icon="true" title="Order and timestamps"}
A naming convention can enable a logical order of the file or folder names when sorting them alphabetically. Here some tips:

- When numbers are included, leading zeros are useful in most cases:
  - with "0":\
    `Scan01.csv`, `Scan02.csv`, `Scan03.csv`, `Scan04.csv`, `Scan05.csv`, `Scan06.csv`,\
    `Scan07.csv`, `Scan08.csv`, `Scan09.csv`, `Scan10.csv`, `Scan11.csv`, `Scan12.csv`
  - without:\
    `Scan1.csv`, `Scan10.csv`, `Scan11.csv`, `Scan12.csv`, `Scan2.csv`, `Scan3.csv`,\
    `Scan4.csv`, `Scan5.csv`, `Scan6.csv`, `Scan7.csv`, `Scan8.csv`, `Scan9.csv`
- Timestamps should always be given with leading zero and in the order 'from big to small', i.e. year, month, day of month, hour, minute, second. This is in compliance with the international format ISO 8601 (e.g. "2024-07-31", "2024-07-31T2313"). Examples:
  - very bad: `13Jan2024`, `21April2021`, `3Dec2025`
  - also bad: `03122025`, `13012024`, `21042021`
  - good: `2021-04-21`, `2024-01-13`, `2025-12-03`
  - also ok: `20210421`, `20240113`, `20251203`
  - including time of day: `20210421T0345`, `20240113T1730`, `20251203T1900` for 03:45, 17:30, 19:00
:::

::: {.callout-note collapse="true" icon="true" title="Good practice for file naming"}
- Include relevant information in the file name. However, don't misuse a file name as a way to store all your metadata.
- Use dashes or underscores for separating semantic parts of a name, e.g. `exp01_step12.csv` or `2024-07-25_run01.tab`
- Avoid overly long names (a maximum of 32 characters is suggested), see also note above about the full path length.
- Avoid to move or rename folders or files. This is especially relevant in case you or others have referred to a file by using the file name or path.
- Generate a README file explaining file nomenclature (including the meaning of acronyms or abbreviations), file organization and versioning. Store this file on top of a folder structure for easy access.

Often, compromises have to be done, for example including relevant information versus avoiding long names. And folder names with a precise and narrow meaning may become outdated when filling it with further content over time.
Because of that, persistent identifiers (PID) typically avoid to include semantic information, e.g. `doi:10.17617/3.1STIJV`.
:::

::: {.callout-note collapse="true" icon="true" title="Versioning"}
Documents may evolve over time. File versioning allows for reverting to earlier versions if needed, and shall allow to keep track of changes, including documentation on the underlying rationale and people involved.

Version control can be done either manually by using naming conventions or by using a version control system like Git. Following hints apply for the manual version control, meaning that you store both in your file system, the current and previous versions.

- Versions should be numbered consecutively, e.g. `Handbook_v3.pdf`. Major changes (v1, v2, v3, ...) can be distinguished from minor ones (v1-1, v1-2, v1-3 or 1a, 1b, 1c). You may use leading zeros if you expect more than nine versions.
- Alternatively, a date or timestamp could be used, e.g. `Handbook_v20240725.pdf`.
- Qualifiers such as "raw" or "processed" for data, or "draft" or "internal" for documents may be used.
- But terms such as "final", "final2", "final-revised", "final-changed_again", "final_ready" can be confusing. In other words: Avoid "final" naming.
- Document your versioning convention, e.g. what you mean with major or minor changes.
- Document the essential changes you have done between the versions.

See also:\
For the releases of software-products, GitHub recommends version names like '1.3.2', details see [Semantic Versioning 2.0.0](https://semver.org/).
:::


### File formats

When storing information in a file, a file format has to be chosen. For the sake of interoperability, the format needs a clear stucture, making it easy to read with many software products (out of the box, or by writing a small script). A clear documentation of the file format shall be publicly available. With that, the chance is high, that the file can be read in future, making ist suitable for long-term preservation. Therefore, open file formats are recommended, while proprietary formats should be avoided.

Ideally, when choosing a good format, has following properties:

- readable by human with simple editor
- readable with many programs
- easy to understand, low complexity
- small (storage space)
- quick to read (performance)

However, compromises have to be done. For example, binary files are usually more performant than csv-files and thus more suitable during the active research process, while csv is a well-established format for long-term preservation.

::: {.callout-tip collapse="false" icon="true" title="Check (\~ 10 minutes)"}
- Are the files in a open or a proprietary format?
- Are they future-proof, i.e. suitable for long-term archiving?
- How easy to open it (available programs, file size)?
- How complex are they, what is their internal structure?
- What about performance and file size?
- How easy to understand them as human?
- Are they machine-readable? How easy to write a script for reading them?
- Which alternative formats exist?
:::

::: {.callout-note collapse="true" icon="true" title="To avoid: Proprietary formats"}
Often, proprietary formats have intentially no proper documentation, in some cases even technical protection-mechanisms, making them readable only by commercial software. This reduces the interoperability and reusability of the files, and in worst case makes them unreadable on the long-term. Furthermore, the files might contain hidden (potenically sensitive) information. Thus, such formats should be avoided.
:::

::: {.callout-note collapse="true" icon="true" title="Examples for recommended formats"}
Following some formats which are widely used, documented and readable with several programs.

- For documentation:
  - Plain text (.txt)
  - HTML, XHTML, Markdown
  - PDF (PDF/A-1)
  - maybe: Rich Text Format (.rtf), Open Document Text (.odt), docx, ...
- Tabular data:
  - Comma-separated values (.csv)
  - Tab-delimited (.tab)
  - maybe: Open Document Spreadsheet (.ods), xlsx, ...
- Nested data:
  - JSON
  - XML
- Further formats:
  - NetCDF, HDF5, ...
  - png, jpg, ...

Notes:

- **PDF**: PDF has been developed by Adobe Inc and thus originally had been a proprietary format, and several versions exist. For archival purposes, a PDF/A version should be taken. PDF is suited for fix documentation, but editing PDF files or extracting data from them is not straightforward.
- **Spreadsheet files**: Spreadsheets may look nice, in particular when being formatted in a colourful way. But for the machine-readability this can cause problems. In particular, you should not represent relevant information just by formatting content in different ways. As a rule of thumb: Spreadsheet files like .xlsx or .ods are not well machine-readable.
:::

::: {.callout-note collapse="true" icon="true" title="Premium format ASCII"}
A kind of gold-standard for storing digital information are ASCII files. In an ASCII file, each byte represents one visible character (except for the white spaces and for control characters like tabstop and linebreaks).

Therefore, except for potential limitations regarding the file size, ASCII files can be read or opened by any text editor or data-processing software, even with programs like Excel, Word, Wordpad or web browsers.

Excursion - Characters beyond ASCII:

> An ASCII file can only contain following visible characters - otherwise it is not an ACII file: ``!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~``
> 
> Since some years, the Unicode-based file format "UTF-8" is available, which can also represent many characters beyond the ASCII characters, like "ü", "€", and even some smilies ☺. Nowadays, UTF-8 is supported by many editors and browsers. And the good thing about UTF-8: As long as a UTF-8 file contains only ASCII characters, the UTF-8 file is automatically an ASCII file. Or in other words: An ASCII file is a super-interoperable UTF-8 file.
:::


### Aspects within a tabular text file - optional

The tasks of this section are optional - for the case that you still have some time, or for reading afterwards.

Even after deciding to store tabular data in text files (i.e. files which can be opened in any editor), there are various ways and conventions to choose:

- Column separator: typically tab or comma, sometimes space or semicolon
- Numeric values: How to deal with missing values - "NA", "", ...
- Representation of timestamps, e.g. "2024-08-01T08:59"
- Header lines with meta information?
- Encoding: Recommended is ASCII or UTF-8

::: {.callout-tip collapse="false" icon="true" title="Check (\~ 5 minutes)"}
- File encoding (ASCII, UTF-8, ?)
- Numbers: precision - enough? too much?
- Special numbers: "NA", "", "N/A", "999", "0"? Meaning of them documented?
- Time: Format of date and time of day, time zone?
- Tables: Choice of separator, whitespaces, missing columns?
- Content self-explaining? Column description? Units? Detailed information elsewhere?
:::

::: {.callout-note collapse="true" icon="false" title="Example for a bad file"}
Following an example for a very bad file, below a better version of it.

File `Measured last month.txt`:
```
date, time,sensor,sensor
03/07/24 12.00 AM,17.3
03/07/24 1.00 AM,16.9
03/07/24 2.00 AM,16.7
03/07/24 3.00 AM,16.4
03/07/24 4.00 AM,16.2
03/07/24 5.00 AM,15.9
03/07/24 6.00 AM
03/07/24 7.00 AM
03/07/24 8.00 AM
03/07/24 9.00 AM,16.5
03/07/24 10.00 AM,17.0,7.2
03/07/24 11.00 AM,17.6,4.6
03/07/24 12.00 PM,18.0
03/07/24 1.00 PM,18.5
```

Comments on that file:

- Already the file name is bad: It contains spaces, and "last month" is only valid for one month.
- That file is not a proper csv file, because it has not a proper tabular shape:
    - The header line has one comma too much, indicating that date and time of day would be in different columns.
    - Most data rows have one comma too few, i.e. the value of the last column is missing.
- The header line contains twice the word "sensor", thus the column names are not unique.
- The time column is horrible:
    - Date is given in an ambiguous format - is it 03 July 2024 or 07 March 2024 or 24 July 2003, or 1924 or in the year 24 AD ? You should use the international format [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), here "2024-03-07" for 7 March 2024.
    - Time is given according to 12h clock with "AM" and "PM". Hint: **Never use "AM" or "PM"** in scientific context, always use 24h clock!
    - The hour is noted without leading zero.
    - Between hour and minute, a dot is used, but a colon should be used, e.g. "00:00"
- Important information is missing (but might be given in a separate readme file or Code book), e.g.:
    - Time zone?
    - What is the file about? What are the other 2 columns?
    - Why missing values?
    - Unit?

And here a better version:
File `Temp_Rain_202407.csv`:
```
# Averaged temperature and precipitation of Ex_Emplum station
#
# File created on 2024-04-22 by Schlaubi Schlumpf.
# This files contains temperature and precipitation measured at the fictitious weather station 'Ex_Emplum' at 55.432 degree North, 55.678 degree East.
# Raw data have been averaged over 1 hour.
# NA indicates missing values due to measurement interruption or instrument malfunction.
# Column description:
#   - Time: Start time of the 1-hour interval, given as UTC, in ISO 8601 format 'YYYY-MM-DDThh:mm'.
#   - Temp: Temperature at 2 m above ground level, averaged over the 1-hour interval, in degree Celsius. The error of the given value is expected to be below 0.3 degree Celsius.
#   - Rain: Precipitation height accumulated within the 1-hour interval, in mm. The error of the given value is expected to be below 0.5 mm.
#
Time,Temp,Rain
2024-03-07T00:00,17.3,0
2024-03-07T01:00,16.9,0
2024-03-07T02:00,16.7,0
2024-03-07T03:00,16.4,0
2024-03-07T04:00,16.2,0
2024-03-07T05:00,15.9,0
2024-03-07T06:00,NA,NA
2024-03-07T07:00,NA,NA
2024-03-07T08:00,NA,NA
2024-03-07T09:00,16.5,0
2024-03-07T10:00,17.0,7.2
2024-03-07T11:00,17.6,4.6
2024-03-07T12:00,18.0,0
2024-03-07T13:00,18.5,0
```
:::


## References

Examples and notes have been adapted from:

- Onboarding into Research Data Management, Franke et al. 2024, [https://hdl.handle.net/21.11116/0000-000E-194D-1](https://hdl.handle.net/21.11116/0000-000E-194D-1), file "FDM-Onboarding-2024_CPT-Slides.pdf" pages 44-51, 56-59.



